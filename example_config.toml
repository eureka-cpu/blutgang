# To use the config file, use the -c/--config option pointing to the path of a config file

# Config for blutgang goes here
[blutgang]
# Clear the cache DB on startup
do_clear = false
# Where to bind blutgang to
address = "127.0.0.1:3000"
# Moving average length for the latency
ma_length = 100
# Sort RPCs by latency on startup. Recommended to leave on.
sort_on_startup = true
# Enable health checking
health_check = true
# Enable content type header checking. Set this to `true` if you want
# Blutgang to be JSON-RPC compliant.
header_check = true
# Acceptable time to wait for a response in ms
ttl = 30
# How many times to retry a request before giving up
max_retries = 32
# Block time in ms, used as a sanity check when not receiving subscriptions
expected_block_time = 13000
# Time between health checks in ms
health_check_ttl = 400
# Supress the health check running info messages
supress_rpc_check = false

# TODO: @eureka-cpu -- perhaps this is better off as a path to a file where this
# priveleged information lives? An environment variable may also work to this end.
#
# Note: the admin namespace contains volatile functions and
# should not be exposed publicly.
[admin]
# Enable the admin namespace
enabled = false
# Address for the admin RPC
address = "127.0.0.1:5715"
# Only allow read-only methods
# Recommended `true` unless you 100% need write methods
readonly = true
# Enable the use of JWT for auth
# Should be on if exposing to the internet
jwt = false
# jwt token
key = ""

# TODO: @eureka-cpu -- For now having two separate tables for different dbs is fine
# since this still needs testing but perhaps a more appropriate approach would be
# to use the toplevel `[blutgang]` for each child of the actual program so it's clear
# at a glance which tables belong to what. For instance `[blutgang.sled]`, `[blutgang.merkle]` etc.
# This also makes toml parsing much more smooth since we know which (sub)table to check for,
# given certain command line options like `--db rocksdb`. The end-goal should allow the user
# to override options in the config from the command line, which can be rather useful for development too.

# Sled config
# Sled is one of the databases we use for our cache, for more info check their docs
[sled]
# Path to db
db_path = "./blutgang-cache"
# Cache size in bytes.
cache_capacity = 1000000000
# Select zstd compression level. Reduces size 60-70%,
# and increases CPU and latency by around 10% for db writes and 2% for reads
compression = 1
# Frequency of flushes in ms
flush_every_ms = 12000

# RocksDB config
# RocksDB is one of the databases we use for our cache, for more info check their docs
[rocksdb]
# TODO: @eureka-cpu -- add rocksdb options here

# Add separate RPCs as TOML tables
# DO NOT name an rpc `blutgang`, `admin`, `sled`, or `rocksdb`
# TODO: @eureka-cpu -- perhaps it would be more idiomatic to have an `rpc_list`
# list instead where users can then define them. We can also use the toml
# parser to throw errors when a reserved namespace is used.
# The below example would then look like:
# [blutgang]
# rpc_list = [
#   {
#     id = "merkle",
#     url = "https://eth.merkle.io",
#     ws_url = "wss://eth.merkle.io",
#     max_consecutive = 150,
#     max_per_second = 200
#   },
#   {
#     id = "alchemy",
#     url = "https://eth.alchemyapi.io",
#     ws_url = "wss://eth.alchemyapi.io",
#     max_consecutive = 100,
#     max_per_second = 150
#   }
# ]
# Or as an array of tables:
# 
# [[blutgang.rpc_list]]
# id = "merkle"
# url = "https://eth.merkle.io"
# ws_url = "wss://eth.merkle.io"
# max_consecutive = 150
# max_per_second = 200
#
# [[blutgang.rpc_list]]
# id = "alchemy"
# url = "https://eth.alchemyapi.io"
# ws_url = "wss://eth.alchemyapi.io"
# max_consecutive = 100
# max_per_second = 150

[merkle]
url = "https://eth.merkle.io"
ws_url = "wss://eth.merkle.io"
# The maximum amount of time we can use this rpc in a row.
max_consecutive = 150
# Max amount of queries per second.
max_per_second = 200
